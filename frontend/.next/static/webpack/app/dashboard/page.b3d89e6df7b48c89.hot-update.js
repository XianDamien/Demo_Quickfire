"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: function() { return /* binding */ ApiError; },\n/* harmony export */   api: function() { return /* binding */ api; }\n/* harmony export */ });\n/* harmony import */ var _mock_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mock-data */ \"(app-pages-browser)/./lib/mock-data.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\nclass ApiError extends Error {\n    constructor(status, message){\n        super(message);\n        this.status = status;\n        this.name = \"ApiError\";\n    }\n}\nasync function fetchApi(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    const response = await fetch(url, {\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        },\n        ...options\n    });\n    if (!response.ok) {\n        const errorData = await response.json().catch(()=>({}));\n        throw new ApiError(response.status, errorData.detail || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n    }\n    return response.json();\n}\nconst api = {\n    // 创建评测任务\n    async createEvaluation (request) {\n        const formData = new FormData();\n        formData.append(\"student_id\", request.student_id);\n        formData.append(\"unit_id\", request.unit_id);\n        formData.append(\"session_index\", request.session_index.toString());\n        formData.append(\"audio_file\", request.audio_file);\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/evaluate/session\"), {\n            method: \"POST\",\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new ApiError(response.status, errorData.detail || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    },\n    // 获取任务状态\n    async getTaskStatus (taskId) {\n        if (_mock_data__WEBPACK_IMPORTED_MODULE_0__.USE_MOCK_DATA) {\n            await (0,_mock_data__WEBPACK_IMPORTED_MODULE_0__.delay)(200);\n            const task = _mock_data__WEBPACK_IMPORTED_MODULE_0__.MOCK_TASKS.find((t)=>t.task_id === taskId);\n            if (!task) {\n                throw new ApiError(404, \"Task not found\");\n            }\n            return task;\n        }\n        return fetchApi(\"/evaluate/task/\".concat(taskId));\n    },\n    // 获取所有评测任务列表\n    async getAllTasks () {\n        if (_mock_data__WEBPACK_IMPORTED_MODULE_0__.USE_MOCK_DATA) {\n            await (0,_mock_data__WEBPACK_IMPORTED_MODULE_0__.delay)(500) // 模拟网络延迟\n            ;\n            return _mock_data__WEBPACK_IMPORTED_MODULE_0__.MOCK_TASKS;\n        }\n        return fetchApi(\"/evaluate/tasks\");\n    },\n    // 获取报告详情\n    async getReportDetail (taskId) {\n        if (_mock_data__WEBPACK_IMPORTED_MODULE_0__.USE_MOCK_DATA) {\n            await (0,_mock_data__WEBPACK_IMPORTED_MODULE_0__.delay)(300);\n            const report = _mock_data__WEBPACK_IMPORTED_MODULE_0__.MOCK_REPORTS.find((r)=>r.task_id === taskId);\n            if (!report) {\n                throw new ApiError(404, \"Report not found\");\n            }\n            return report;\n        }\n        return fetchApi(\"/evaluate/report/\".concat(taskId));\n    },\n    // 提交教师反馈\n    async submitTeacherFeedback (feedback) {\n        if (_mock_data__WEBPACK_IMPORTED_MODULE_0__.USE_MOCK_DATA) {\n            await (0,_mock_data__WEBPACK_IMPORTED_MODULE_0__.delay)(800);\n            console.log(\"Mock: Submitted teacher feedback:\", feedback);\n            return {\n                success: true\n            };\n        }\n        return fetchApi(\"/evaluate/feedback\", {\n            method: \"POST\",\n            body: JSON.stringify(feedback)\n        });\n    },\n    // 教师批准评测结果\n    async approveTask (taskId, finalGrade, teacherComment) {\n        if (_mock_data__WEBPACK_IMPORTED_MODULE_0__.USE_MOCK_DATA) {\n            await (0,_mock_data__WEBPACK_IMPORTED_MODULE_0__.delay)(500);\n            console.log(\"Mock: Approved task:\", taskId);\n            return {\n                success: true,\n                approved_at: new Date().toISOString()\n            };\n        }\n        return fetchApi(\"/evaluate/task/\".concat(taskId, \"/approve\"), {\n            method: \"POST\",\n            body: JSON.stringify({\n                task_id: taskId,\n                final_grade: finalGrade,\n                teacher_comment: teacherComment\n            })\n        });\n    },\n    // 批量导出结果\n    async exportResults (taskIds) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/evaluate/export\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                task_ids: taskIds\n            })\n        });\n        if (!response.ok) {\n            throw new ApiError(response.status, \"Export failed\");\n        }\n        return response.blob();\n    },\n    // 健康检查\n    async healthCheck () {\n        return fetchApi(\"/health\");\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU80RTtBQUU1RSxNQUFNSSxlQUFlQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO0FBRXhELE1BQU1DLGlCQUFpQkM7SUFDckJDLFlBQVksTUFBcUIsRUFBRUUsT0FBZSxDQUFFO1FBQ2xELEtBQUssQ0FBQ0E7YUFEV0QsU0FBQUE7UUFFakIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsZUFBZUMsU0FDYkMsUUFBZ0I7UUFDaEJDLFVBQUFBLGlFQUF1QixDQUFDO0lBRXhCLE1BQU1DLE1BQU0sR0FBa0JGLE9BQWZYLGNBQXdCLE9BQVRXO0lBRTlCLE1BQU1HLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztRQUNoQ0csU0FBUztZQUNQLGdCQUFnQjtZQUNoQixHQUFHSixRQUFRSSxPQUFPO1FBQ3BCO1FBQ0EsR0FBR0osT0FBTztJQUNaO0lBRUEsSUFBSSxDQUFDRSxTQUFTRyxFQUFFLEVBQUU7UUFDaEIsTUFBTUMsWUFBWSxNQUFNSixTQUFTSyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7UUFDdEQsTUFBTSxJQUFJaEIsU0FDUlUsU0FBU1AsTUFBTSxFQUNmVyxVQUFVRyxNQUFNLElBQUksUUFBNEJQLE9BQXBCQSxTQUFTUCxNQUFNLEVBQUMsTUFBd0IsT0FBcEJPLFNBQVNRLFVBQVU7SUFFdkU7SUFFQSxPQUFPUixTQUFTSyxJQUFJO0FBQ3RCO0FBRU8sTUFBTUksTUFBTTtJQUNqQixTQUFTO0lBQ1QsTUFBTUMsa0JBQWlCQyxPQUFnQztRQUNyRCxNQUFNQyxXQUFXLElBQUlDO1FBQ3JCRCxTQUFTRSxNQUFNLENBQUMsY0FBY0gsUUFBUUksVUFBVTtRQUNoREgsU0FBU0UsTUFBTSxDQUFDLFdBQVdILFFBQVFLLE9BQU87UUFDMUNKLFNBQVNFLE1BQU0sQ0FBQyxpQkFBaUJILFFBQVFNLGFBQWEsQ0FBQ0MsUUFBUTtRQUMvRE4sU0FBU0UsTUFBTSxDQUFDLGNBQWNILFFBQVFRLFVBQVU7UUFFaEQsTUFBTW5CLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiZixjQUFhLHNCQUFvQjtZQUMvRGtDLFFBQVE7WUFDUkMsTUFBTVQ7UUFDUjtRQUVBLElBQUksQ0FBQ1osU0FBU0csRUFBRSxFQUFFO1lBQ2hCLE1BQU1DLFlBQVksTUFBTUosU0FBU0ssSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBQ3RELE1BQU0sSUFBSWhCLFNBQ1JVLFNBQVNQLE1BQU0sRUFDZlcsVUFBVUcsTUFBTSxJQUFJLFFBQTRCUCxPQUFwQkEsU0FBU1AsTUFBTSxFQUFDLE1BQXdCLE9BQXBCTyxTQUFTUSxVQUFVO1FBRXZFO1FBRUEsT0FBT1IsU0FBU0ssSUFBSTtJQUN0QjtJQUVBLFNBQVM7SUFDVCxNQUFNaUIsZUFBY0MsTUFBYztRQUNoQyxJQUFJdEMscURBQWFBLEVBQUU7WUFDakIsTUFBTUQsaURBQUtBLENBQUM7WUFDWixNQUFNd0MsT0FBTzFDLGtEQUFVQSxDQUFDMkMsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxPQUFPLEtBQUtKO1lBQ2hELElBQUksQ0FBQ0MsTUFBTTtnQkFDVCxNQUFNLElBQUlsQyxTQUFTLEtBQUs7WUFDMUI7WUFDQSxPQUFPa0M7UUFDVDtRQUNBLE9BQU81QixTQUF5QixrQkFBeUIsT0FBUDJCO0lBQ3BEO0lBRUEsYUFBYTtJQUNiLE1BQU1LO1FBQ0osSUFBSTNDLHFEQUFhQSxFQUFFO1lBQ2pCLE1BQU1ELGlEQUFLQSxDQUFDLEtBQUssU0FBUzs7WUFDMUIsT0FBT0Ysa0RBQVVBO1FBQ25CO1FBQ0EsT0FBT2MsU0FBMkI7SUFDcEM7SUFFQSxTQUFTO0lBQ1QsTUFBTWlDLGlCQUFnQk4sTUFBYztRQUNsQyxJQUFJdEMscURBQWFBLEVBQUU7WUFDakIsTUFBTUQsaURBQUtBLENBQUM7WUFDWixNQUFNOEMsU0FBUy9DLG9EQUFZQSxDQUFDMEMsSUFBSSxDQUFDTSxDQUFBQSxJQUFLQSxFQUFFSixPQUFPLEtBQUtKO1lBQ3BELElBQUksQ0FBQ08sUUFBUTtnQkFDWCxNQUFNLElBQUl4QyxTQUFTLEtBQUs7WUFDMUI7WUFDQSxPQUFPd0M7UUFDVDtRQUNBLE9BQU9sQyxTQUFxQixvQkFBMkIsT0FBUDJCO0lBQ2xEO0lBRUEsU0FBUztJQUNULE1BQU1TLHVCQUFzQkMsUUFBeUI7UUFDbkQsSUFBSWhELHFEQUFhQSxFQUFFO1lBQ2pCLE1BQU1ELGlEQUFLQSxDQUFDO1lBQ1prRCxRQUFRQyxHQUFHLENBQUMscUNBQXFDRjtZQUNqRCxPQUFPO2dCQUFFRyxTQUFTO1lBQUs7UUFDekI7UUFDQSxPQUFPeEMsU0FBK0Isc0JBQXNCO1lBQzFEd0IsUUFBUTtZQUNSQyxNQUFNZ0IsS0FBS0MsU0FBUyxDQUFDTDtRQUN2QjtJQUNGO0lBRUEsV0FBVztJQUNYLE1BQU1NLGFBQVloQixNQUFjLEVBQUVpQixVQUFrQixFQUFFQyxjQUFzQjtRQUMxRSxJQUFJeEQscURBQWFBLEVBQUU7WUFDakIsTUFBTUQsaURBQUtBLENBQUM7WUFDWmtELFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0JaO1lBQ3BDLE9BQU87Z0JBQUVhLFNBQVM7Z0JBQU1NLGFBQWEsSUFBSUMsT0FBT0MsV0FBVztZQUFHO1FBQ2hFO1FBQ0EsT0FBT2hELFNBQW9ELGtCQUF5QixPQUFQMkIsUUFBTyxhQUFXO1lBQzdGSCxRQUFRO1lBQ1JDLE1BQU1nQixLQUFLQyxTQUFTLENBQUM7Z0JBQ25CWCxTQUFTSjtnQkFDVHNCLGFBQWFMO2dCQUNiTSxpQkFBaUJMO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLFNBQVM7SUFDVCxNQUFNTSxlQUFjQyxPQUFpQjtRQUNuQyxNQUFNaEQsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJmLGNBQWEscUJBQW1CO1lBQzlEa0MsUUFBUTtZQUNSbEIsU0FBUztnQkFDUCxnQkFBZ0I7WUFDbEI7WUFDQW1CLE1BQU1nQixLQUFLQyxTQUFTLENBQUM7Z0JBQUVXLFVBQVVEO1lBQVE7UUFDM0M7UUFFQSxJQUFJLENBQUNoRCxTQUFTRyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJYixTQUFTVSxTQUFTUCxNQUFNLEVBQUU7UUFDdEM7UUFFQSxPQUFPTyxTQUFTa0QsSUFBSTtJQUN0QjtJQUVBLE9BQU87SUFDUCxNQUFNQztRQUNKLE9BQU92RCxTQUE2QjtJQUN0QztBQUNGLEVBQUM7QUFFa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS50cz82OGExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxyXG4gIFJlcG9ydERhdGEsIFxyXG4gIEV2YWx1YXRpb25UYXNrLCBcclxuICBDcmVhdGVFdmFsdWF0aW9uUmVxdWVzdCwgXHJcbiAgQ3JlYXRlRXZhbHVhdGlvblJlc3BvbnNlLFxyXG4gIFRlYWNoZXJGZWVkYmFja1xyXG59IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IE1PQ0tfVEFTS1MsIE1PQ0tfUkVQT1JUUywgZGVsYXksIFVTRV9NT0NLX0RBVEEgfSBmcm9tICcuL21vY2stZGF0YSdcclxuXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCdcclxuXHJcbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGF0dXM6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihtZXNzYWdlKVxyXG4gICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJ1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBcGk8VD4oXHJcbiAgZW5kcG9pbnQ6IHN0cmluZywgXHJcbiAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxyXG4pOiBQcm9taXNlPFQ+IHtcclxuICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gXHJcbiAgXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgfSxcclxuICAgIC4uLm9wdGlvbnMsXHJcbiAgfSlcclxuXHJcbiAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXHJcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IoXHJcbiAgICAgIHJlc3BvbnNlLnN0YXR1cywgXHJcbiAgICAgIGVycm9yRGF0YS5kZXRhaWwgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYXBpID0ge1xyXG4gIC8vIOWIm+W7uuivhOa1i+S7u+WKoVxyXG4gIGFzeW5jIGNyZWF0ZUV2YWx1YXRpb24ocmVxdWVzdDogQ3JlYXRlRXZhbHVhdGlvblJlcXVlc3QpOiBQcm9taXNlPENyZWF0ZUV2YWx1YXRpb25SZXNwb25zZT4ge1xyXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxyXG4gICAgZm9ybURhdGEuYXBwZW5kKCdzdHVkZW50X2lkJywgcmVxdWVzdC5zdHVkZW50X2lkKVxyXG4gICAgZm9ybURhdGEuYXBwZW5kKCd1bml0X2lkJywgcmVxdWVzdC51bml0X2lkKVxyXG4gICAgZm9ybURhdGEuYXBwZW5kKCdzZXNzaW9uX2luZGV4JywgcmVxdWVzdC5zZXNzaW9uX2luZGV4LnRvU3RyaW5nKCkpXHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2F1ZGlvX2ZpbGUnLCByZXF1ZXN0LmF1ZGlvX2ZpbGUpXHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2V2YWx1YXRlL3Nlc3Npb25gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcclxuICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKFxyXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cywgXHJcbiAgICAgICAgZXJyb3JEYXRhLmRldGFpbCB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXHJcbiAgfSxcclxuXHJcbiAgLy8g6I635Y+W5Lu75Yqh54q25oCBXHJcbiAgYXN5bmMgZ2V0VGFza1N0YXR1cyh0YXNrSWQ6IHN0cmluZyk6IFByb21pc2U8RXZhbHVhdGlvblRhc2s+IHtcclxuICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XHJcbiAgICAgIGF3YWl0IGRlbGF5KDIwMClcclxuICAgICAgY29uc3QgdGFzayA9IE1PQ0tfVEFTS1MuZmluZCh0ID0+IHQudGFza19pZCA9PT0gdGFza0lkKVxyXG4gICAgICBpZiAoIXRhc2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoNDA0LCAnVGFzayBub3QgZm91bmQnKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXNrXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmV0Y2hBcGk8RXZhbHVhdGlvblRhc2s+KGAvZXZhbHVhdGUvdGFzay8ke3Rhc2tJZH1gKVxyXG4gIH0sXHJcblxyXG4gIC8vIOiOt+WPluaJgOacieivhOa1i+S7u+WKoeWIl+ihqFxyXG4gIGFzeW5jIGdldEFsbFRhc2tzKCk6IFByb21pc2U8RXZhbHVhdGlvblRhc2tbXT4ge1xyXG4gICAgaWYgKFVTRV9NT0NLX0RBVEEpIHtcclxuICAgICAgYXdhaXQgZGVsYXkoNTAwKSAvLyDmqKHmi5/nvZHnu5zlu7bov59cclxuICAgICAgcmV0dXJuIE1PQ0tfVEFTS1NcclxuICAgIH1cclxuICAgIHJldHVybiBmZXRjaEFwaTxFdmFsdWF0aW9uVGFza1tdPignL2V2YWx1YXRlL3Rhc2tzJylcclxuICB9LFxyXG5cclxuICAvLyDojrflj5bmiqXlkYror6bmg4VcclxuICBhc3luYyBnZXRSZXBvcnREZXRhaWwodGFza0lkOiBzdHJpbmcpOiBQcm9taXNlPFJlcG9ydERhdGE+IHtcclxuICAgIGlmIChVU0VfTU9DS19EQVRBKSB7XHJcbiAgICAgIGF3YWl0IGRlbGF5KDMwMClcclxuICAgICAgY29uc3QgcmVwb3J0ID0gTU9DS19SRVBPUlRTLmZpbmQociA9PiByLnRhc2tfaWQgPT09IHRhc2tJZClcclxuICAgICAgaWYgKCFyZXBvcnQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQXBpRXJyb3IoNDA0LCAnUmVwb3J0IG5vdCBmb3VuZCcpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlcG9ydFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZldGNoQXBpPFJlcG9ydERhdGE+KGAvZXZhbHVhdGUvcmVwb3J0LyR7dGFza0lkfWApXHJcbiAgfSxcclxuXHJcbiAgLy8g5o+Q5Lqk5pWZ5biI5Y+N6aaIXHJcbiAgYXN5bmMgc3VibWl0VGVhY2hlckZlZWRiYWNrKGZlZWRiYWNrOiBUZWFjaGVyRmVlZGJhY2spOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XHJcbiAgICBpZiAoVVNFX01PQ0tfREFUQSkge1xyXG4gICAgICBhd2FpdCBkZWxheSg4MDApXHJcbiAgICAgIGNvbnNvbGUubG9nKCdNb2NrOiBTdWJtaXR0ZWQgdGVhY2hlciBmZWVkYmFjazonLCBmZWVkYmFjaylcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmV0Y2hBcGk8eyBzdWNjZXNzOiBib29sZWFuIH0+KCcvZXZhbHVhdGUvZmVlZGJhY2snLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFjayksXHJcbiAgICB9KVxyXG4gIH0sXHJcblxyXG4gIC8vIOaVmeW4iOaJueWHhuivhOa1i+e7k+aenFxyXG4gIGFzeW5jIGFwcHJvdmVUYXNrKHRhc2tJZDogc3RyaW5nLCBmaW5hbEdyYWRlOiBzdHJpbmcsIHRlYWNoZXJDb21tZW50OiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgYXBwcm92ZWRfYXQ6IHN0cmluZyB9PiB7XHJcbiAgICBpZiAoVVNFX01PQ0tfREFUQSkge1xyXG4gICAgICBhd2FpdCBkZWxheSg1MDApXHJcbiAgICAgIGNvbnNvbGUubG9nKCdNb2NrOiBBcHByb3ZlZCB0YXNrOicsIHRhc2tJZClcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgYXBwcm92ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmV0Y2hBcGk8eyBzdWNjZXNzOiBib29sZWFuOyBhcHByb3ZlZF9hdDogc3RyaW5nIH0+KGAvZXZhbHVhdGUvdGFzay8ke3Rhc2tJZH0vYXBwcm92ZWAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICB0YXNrX2lkOiB0YXNrSWQsXHJcbiAgICAgICAgZmluYWxfZ3JhZGU6IGZpbmFsR3JhZGUsXHJcbiAgICAgICAgdGVhY2hlcl9jb21tZW50OiB0ZWFjaGVyQ29tbWVudCxcclxuICAgICAgfSksXHJcbiAgICB9KVxyXG4gIH0sXHJcblxyXG4gIC8vIOaJuemHj+WvvOWHuue7k+aenFxyXG4gIGFzeW5jIGV4cG9ydFJlc3VsdHModGFza0lkczogc3RyaW5nW10pOiBQcm9taXNlPEJsb2I+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9ldmFsdWF0ZS9leHBvcnRgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0YXNrX2lkczogdGFza0lkcyB9KSxcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCAnRXhwb3J0IGZhaWxlZCcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKVxyXG4gIH0sXHJcblxyXG4gIC8vIOWBpeW6t+ajgOafpVxyXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZyB9PiB7XHJcbiAgICByZXR1cm4gZmV0Y2hBcGk8eyBzdGF0dXM6IHN0cmluZyB9PignL2hlYWx0aCcpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBBcGlFcnJvciB9XHJcbiJdLCJuYW1lcyI6WyJNT0NLX1RBU0tTIiwiTU9DS19SRVBPUlRTIiwiZGVsYXkiLCJVU0VfTU9DS19EQVRBIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBcGlFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJzdGF0dXMiLCJtZXNzYWdlIiwibmFtZSIsImZldGNoQXBpIiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsImRldGFpbCIsInN0YXR1c1RleHQiLCJhcGkiLCJjcmVhdGVFdmFsdWF0aW9uIiwicmVxdWVzdCIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJzdHVkZW50X2lkIiwidW5pdF9pZCIsInNlc3Npb25faW5kZXgiLCJ0b1N0cmluZyIsImF1ZGlvX2ZpbGUiLCJtZXRob2QiLCJib2R5IiwiZ2V0VGFza1N0YXR1cyIsInRhc2tJZCIsInRhc2siLCJmaW5kIiwidCIsInRhc2tfaWQiLCJnZXRBbGxUYXNrcyIsImdldFJlcG9ydERldGFpbCIsInJlcG9ydCIsInIiLCJzdWJtaXRUZWFjaGVyRmVlZGJhY2siLCJmZWVkYmFjayIsImNvbnNvbGUiLCJsb2ciLCJzdWNjZXNzIiwiSlNPTiIsInN0cmluZ2lmeSIsImFwcHJvdmVUYXNrIiwiZmluYWxHcmFkZSIsInRlYWNoZXJDb21tZW50IiwiYXBwcm92ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmaW5hbF9ncmFkZSIsInRlYWNoZXJfY29tbWVudCIsImV4cG9ydFJlc3VsdHMiLCJ0YXNrSWRzIiwidGFza19pZHMiLCJibG9iIiwiaGVhbHRoQ2hlY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});